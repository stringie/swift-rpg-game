class DefaultMapTile: MapTile {
  var type: MapTileType
  var state: String

  init(type: MapTileType) {
    self.type = type
    self.state = ""
  }
}

class MazeGenerator: MapGenerator {
  func generate(players: [Player]) -> Map {
    print("Генериране на карта...")

    var mapSize: Int = 0

    repeat {
      print("Моля въведете желания размер на картата (Пример: \"30\", max: 99, min: 10): ")
      if let size = Int(readLine()!) {
        mapSize = size
      } else {
        print("Невалиден вход! Моля, опитай пак.")  
      }
    } while mapSize == 0 || mapSize < 10 || mapSize > 99

    // initialize empty maze of size mapSize
    var maze: [[MapTile]] = Array(generating: { _ in Array(generating: { _ in self.create(type: "empty")}, count: mapSize)}, count: mapSize)

    // load wall tile around maze circumference
    maze[0] = Array(repeating: self.create(type: "wall"), count: mapSize)
    maze[mapSize-1] = Array(repeating: self.create(type: "wall"), count: mapSize)
    for i in 1 ..< mapSize-1 {
      maze[i][0] = self.create(type: "wall")
      maze[i][mapSize-1] = self.create(type: "wall")
    }

    // load objects randomly around map with specific counts for teleporters, players and chests
    var playerPositions: [(Int, Int)] = []
    var teleportPositions: [(Int, Int)] = []
    let objects = ["player", "teleport", "chest", "rock", "wall"]
    let objectCounts = [players.count, 2, players.count * 2, mapSize / 2, mapSize / 2]
    for object in zip(objects, objectCounts) {
      for _ in 1 ... object.1 {
        
        var pos: (Int, Int) = (0, 0)
        repeat {
          pos = (Int.random(in: 1 ..< mapSize-1), Int.random(in: 1 ..< mapSize-1))
        } while maze[pos.0][pos.1].type != MapTileType.empty
        
        maze[pos.0][pos.1] = self.create(type: object.0)
        
        if object.0 == "player" {
          playerPositions.append(pos)
        } else if object.0 == "teleport" {
          teleportPositions.append(pos)
        }
      }
    }

    // create map and return
    let map = DefaultMap(players: players)
    map.setMazeDetails(maze: maze, playerPositions: playerPositions, teleportPositions: teleportPositions)

    return map
  }

  private func create(type: String) -> MapTile {
    switch type {
      case "rock": return DefaultMapTile(type: MapTileType.rock)
      case "teleport": return DefaultMapTile(type: MapTileType.teleport)
      case "wall": return DefaultMapTile(type: MapTileType.wall)
      case "player": return DefaultMapTile(type: MapTileType.player)
      case "empty": return DefaultMapTile(type: MapTileType.empty)
      case "chest": return DefaultMapTile(type: MapTileType.chest)
      default: return DefaultMapTile(type: MapTileType.empty)
    }
  }
}

extension Array {    
    /// Create a new Array whose values are generated by the given closure.
    /// - Parameters:
    ///     - count:            The number of elements to generate
    ///     - elementGenerator: The closure that generates the elements.
    ///                         The index into which the element will be
    ///                         inserted is passed into the closure.
    public init(generating elementGenerator: (Int) -> Element, count: Int) {
        self = (0..<count).map(elementGenerator)
    }
}